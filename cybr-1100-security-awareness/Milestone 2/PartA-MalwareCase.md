# Case Project
For my case study I chose to do Case Project 3-2: Reasons for Zero-Day Attacks. Zero-Day attacks have sadly been prevalent since coded projects have been released. With computer programming being as complicated as it is, security is not always a consideration so much as functionality and dependability. Due to this and multiple other reasons Zero-Day Attacks will likely always be an issue that we as consumers and cybersecurity professionals will have to deal with and be aware of. As mentioned before, many programmers don’t think the same way attackers and testing isn’t always as robust as it should be but what are a couple other reasons for zero-day attacks being so commonplace? 

# Reasons for Zero-Day Attacks
Threat actors are always on the lookout for zero-day vulnerabilities since they are often seen as the holy grail of exploits and these can be a major threat for any company that deals with them. The common timeline follows as the software is developed and released, attackers will find an exploit that they missed. This exploit will be disclosed and a patch will be developed and deployed, usually quickly. When we look at CVEs we can get a picture as to where the issue often arises with programs. One of the major reasons for zero-day attacks is lack of knowledge by the coder themselves. A common issue found and reported in CVEs is buffer overflows and input validation errors, both of which can be exploited by a keen attacker. While we will always make mistakes, it grows the importance of learning and practicing these skills. Mistakes are where the most growth happens, but you don’t have to wait on your own when you can learn from others.

The second reason I would add is attached to the first and I would say it's a matter of Quality Assurance not upholding company standards and carefully vetting code for known exploits. For languages such as C and C++ where some exploits such as Out-of-Bounds Writes and Reads are so well known, there should be checklists in place to verify against these exploits after functionality has been tested. I would say in addition to stronger programmers, a more robust system of QA and perhaps a buddy system to help check each other's code projects. Another fix that could be adapted at the developer and QA level is adapting AI to see these flags and compare them against all current CVE’s. AI is often a bandwagon word that is thrown around but using them for picking out code vulnerabilities would be an excellent case and a great tool for all programmers. 

Another reason is a more nefarious reason, but code could be leaked for profit and purposely not fixed. In some cases in the past. These threats would certainly fall under insider threats and be black hat motivations to maliciously sell your zero-day exploits to attackers. There is a very large market for these exploits that attackers can use to deploy their ransomware or other malware. A counter to this would be carefully vetting programmers and people who have access to this code, practicing systems of least-trust and compartmentalization. Op-Sec should be a crucial component of the programming process, especially if the code being injected or exploited could cause major damages. 

Finally I think sometimes the problem isn’t necessarily with the codes the programmers wrote, but more so with the APIs they used and the vulnerabilities that attackers use to crack them. Not to go through all the methods but some common attacks used against APIs are: BOLA- Broken Object Level Authorization, which can happen when an API fails to enforce permissions checks on object identifiers, allowing attackers to alter references to access unauthorized data; Broken Authentication, which is where improperly configured authentication systems allow attackers to use user tokens and assume identity of an authorized user, allowing for permissions escalation and damage. There are many other API attacks that hackers can use but most follow the same system of taking improperly configured authentication or authorization and escalating their abilities. This makes it important to properly vet the APIs used in a project and use trusted libraries so as to not introduce exploits into your code without your knowledge.  

# Why Does This Matter
I found this case study to be difficult at first, but the more you look the more avenues that attackers can use just to attack the code of a program. There are thousands of attack methods to exploit potential weaknesses and oversights in just the code, not the end user, or their network systems, or the website they're using, but the code that most of us would consider well-made, but small implementation issues or API configurations allow for attackers to inject malicious code. A common one that threat actors will utilize in conjunction with these exploits, is deploying malicious worms.

Worms are a type of malware that doesn’t need an end user to interact with them in order for them to start replicating. As soon as they reach an end device or a server, they begin duplicating. The issue with worms is that they can jump across the network from infected end-points to other, uninfected end-points and start the process again. These can spread through executable programs, emails, trojans, or the network itself with peer-to-peer file sharing systems, and sometimes even without those. A prime example of the destructiveness of worms is programs like WANNACRY. WANNACRY was a worm engineered by North Korea that when released onto the world in 2017, infected over 300,000 computers in 150 different countries. WANNACRY was developed as a ransomware worm that would hold files and computer systems hostage by encrypting the whole system and bouncing to the next computer. This attack cost an estimated $4 billion in losses and damages. This is a good example of the reach and impact of the worm, but also how attackers are able to hand craft their malware to conjoin what would be several different packages. 

# How Does This Apply to CKARS
If CKARS got their network and endpoint devices infected with a worm, potentially with ransomware as seen with WANNACRY, this would not be good for the business but wouldn’t make him close up shop. Not having access to payment programs would force him to use old school billing and receipt systems. His online presence would be shut down but he has enough word of mouth and returning customers that it wouldn’t shut down his business. The biggest issue I see is that specialty jobs that require technical documentation, such as a transmission rebuild, would be more difficult without the proper guidance. He is resourceful enough to likely find or call the manufacturer and receive new documentation but this would certainly make his work flow much harder. Luckily his business is a hand-on job that doesn’t need computers to finish. They make his job and life easier but this field has been around since before computers. While the complexity of the job has gone up, the core of his job benefits from a secure network with documentation but is less than necessary for him to work on cars. 

While it is not going to stop his business from running, the benefit of having a secure network that he can host his documentation, vehicle maintenance guides, and his website is a major benefit to him and his business. With that, having a robust level of security for his network along with an increased knowledge of what to avoid would be an excellent tool in his pocket. One mitigation method would be to carefully vet programs you use. There are hundreds of programs created everyday to help mechanics with their shops, but using well known and supported programs can help avoid future headaches. Another and likely simpler mitigation is a refresher on phishing techniques and how hard they can be to detect. Most of these malware attacks start with someone clicking on a link from an email or unknowingly downloading the file that will corrupt their whole systems. Knowledge is oftentimes the best defense. Finally, having an up-to-date anti-virus system along with a properly configured firewall would go a long way, along with a recommendation of a physical firewall in the future as his network expands. 

Having a more in-depth knowledge of how attackers gain access to systems almost always helps build better defenses. This may better help us to avoid programs when they get released, so we do not fall prey to zero-day attacks, rather waiting for them to go through their natural patching process before using them. While having a better understanding of how attackers can manipulate poor coding in programs may not benefit this owner as much as a bank owner, it still helps us with vetting programs he uses for his vehicle repair business. Cybersecurity is an ongoing challenge since the attacker just needs to get lucky once, so people in this field need to build their knowledge on all aspects of attack patterns and develop robust and layered defense models. 
